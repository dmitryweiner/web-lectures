<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>React - Запросы в сеть</title>
    <link rel="shortcut icon" href="./favicon.ico"/>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/serif.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

## React - Запросы в сеть

![react network](assets/fetch/api.png)

[все лекции](https://github.com/dmitryweiner/lectures/blob/main/README.md)

[Видео](https://youtu.be/wKuWpQrqquE)</script></section><section  data-markdown><script type="text/template">
### Как делать запросы?
* С помощью Fetch API: `fetch("URL")`
* Библиотека [react-query](https://github.com/tanstack/query)
* Библиотека [react-fetching-library](https://github.com/marcin-piela/react-fetching-library#readme)</script></section><section  data-markdown><script type="text/template">
### Задача
* Написать компонент, отображающий форму:
<br/><label>
ID:
<input><br/>
</label>
<button>Получить данные!</button> 
* При нажатии кнопки компонент обращается в API:
https://jsonplaceholder.typicode.com/posts/:id
* Полученные результаты показываются на экране. Поля `title` и `body`:

```json
{
    "userId": 1,
    "id": 4,
    "title": "eum et est occaecati",
    "body": "ullam et saepe reiciendis voluptatem adipisci\nsit amet autem assumenda provident rerum culpa\nquis hic commodi nesciunt rem tenetur doloremque ipsam iure\nquis sunt voluptatem rerum illo velit"
}
```  </script></section><section  data-markdown><script type="text/template">
### Создадим разметку и базовый стейт
```tsx
import {FormEvent, useState} from "react";

export default function Fetcher() {
    const [id, setId] = useState("");

    const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        // TODO fetch
    };

    return <form onSubmit={handleSubmit}>
        <label>
            ID:
            <input type="text" value={id} onChange={e => setId(e.target.value)}/>            <br/>
        </label>
        <button type="submit">Получить данные!</button>
    </form>;
}
```</script></section><section  data-markdown><script type="text/template">
### Отправка запроса
```ts
type Result = {
    userId: string;
    id: string;
    title: string;
    body: string;
} | undefined;

const URL = "https://jsonplaceholder.typicode.com/posts";

// in component
const handleSubmit = async (e: FormEvent<HTMLFormElement>) => { // async!
    e.preventDefault();
    const response = await fetch(`${URL}/${id}`); // await!
    const data = await response.json();
    setResult(data);
};
```</script></section><section  data-markdown><script type="text/template">
### Вывод результатов
```tsx
// in component
{result && <div>
    <b>{result?.title}</b><br/>
    {result?.body}
</div>}
```</script></section><section  data-markdown><script type="text/template">
### А как же обработка ошибок?
```tsx
const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError("");
    try {
        const response = await fetch(`${URL}/${id}`);
        if (response.status !== 200) {
            throw Error(response.statusText);
        }
        const data = await response.json();
        setResult(data);
    } catch (e) {
        if (e instanceof Error) {
            setError(e.message);
        }
    }
};
// ...
{error && <div className={styles.error}>{error}</div>}
```</script></section><section  data-markdown><script type="text/template">
### Всё в сборе
```tsx
import {FormEvent, useState} from "react";
import styles from "./Fetcher.module.css";

type Result = {
    userId: string;
    id: string;
    title: string;
    body: string;
} | undefined;

const URL = "https://jsonplaceholder.typicode.com/posts";

export default function Fetcher() {
    const [id, setId] = useState("");
    const [error, setError] = useState("");
    const [result, setResult] = useState<Result>();

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        setError("");
        try {
            const response = await fetch(`${URL}/${id}`);
            if (response.status !== 200) {
                throw Error(response.statusText);
            } 
            const data = await response.json();
            setResult(data);
        } catch (e) {
            if (e instanceof Error) {
                setError(e.message);
            }
        }
    };

    return <form onSubmit={handleSubmit}>
        <label>
            ID:
            <input type="text" value={id} onChange={e => setId(e.target.value)}/>
            <br/>
        </label>
        <button type="submit">Получить данные!</button>
        {result && <div>
            <b>{result?.title}</b><br/>
            {result?.body}
        </div>}
        {error && <div className={styles.error}>{error}</div>}
    </form>;
}
```</script></section><section  data-markdown><script type="text/template">
### Отправка `POST`
```tsx
const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError("");
    try {
        const data = {
          // данные из формы
          login: "admin",
          password: "123"
        };
        const response = await fetch(URL, {
            method: "POST",
            headers: {
              "Accept": "application/json",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        });
        const result = await response.json();
        setResult(data);
    } catch (e) {
        if (e instanceof Error) {
            setError(e.message);
        }
    }
};
```</script></section><section  data-markdown><script type="text/template">
### Аутентификация
* При логине на сервер, использующий аутентификацию с помощью кук с атрибутом `httpOnly`
(как в [этой лекции](https://dmitryweiner.github.io/web-lectures/Express.html#/28)).
* Необходимо передать в fetch параметр `credentials: "include"`:
```js
const response = await fetch("/auth", {
    method: "POST",
    credentials: "include", // ВАЖНО!
    headers: {
      "Accept": "application/json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
        login: "admin",
        
    })
});
```</script></section><section  data-markdown><script type="text/template">
### Аутентификация
* После успешно аутентификации все запросы, предполагающие передачу авторизационных кук,
следует также делать с этой опцией:
```js
const response = await fetch("/user", {
    method: "GET",
    credentials: "include", // ВАЖНО!
});
```
* Пример работающего механизма аутентификации есть в этом репозитории:
  * [express-auth-example](https://github.com/dmitryweiner/express-auth-example).</script></section><section  data-markdown><script type="text/template">
### Плюсы и минусы
* Плюсы:
    * Просто.
* Минусы:
    * Нет кеширования.
    * Нет состояния загрузки.
    * Лапшекод.
* __Вывод__: надо использовать библиотеку [React Query](https://dmitryweiner.github.io/web-lectures/React%20-%20Query.html#/).</script></section><section  data-markdown><script type="text/template">
### Задачи
* Написать компонент, отображающий форму:
    <br/><label>
    ID:
    <input>
    </label>
    <button>Получить данные!</button><br/> 
* При нажатии кнопки компонент обращается по адресу https://jsonplaceholder.typicode.com/posts/:id.
* Также компонент обращается по адресу https://jsonplaceholder.typicode.com/users/:userId, где `userId` получен из предыдущих данных.
* Показать экране: из post - поля `title` и `body`, из user - поля `name`, `email`.</script></section><section  data-markdown><script type="text/template">
### Задачи
* То же, что и на предыдущей странице, но с отображением состояния загрузки.

![spinner](assets/fetch/loading-gif.gif)</script></section><section  data-markdown><script type="text/template">
* Склонировать [репозиторий](https://github.com/dmitryweiner/mini-chat-server), запустить сервер.
* Из форм, 
[написанных ранее](https://dmitryweiner.github.io/web-lectures/React%20-%20Form%20validation.html#/) 
(логин и регистрация), отправлять запросы:
  * Регистрация: `POST /user`
  ```json
    { "nickname": "test", "password": "123" }
  ```
  * Логин: `POST /auth`
  ```json
    { "nickname": "test", "password": "123" }
  ```
* После успешной регистрации перенаправлять на логин.
После успешной авторизации перенаправлять на / (Home). 
</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
